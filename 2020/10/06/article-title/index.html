<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>blur</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,700;1,700&display=swap" rel="stylesheet">
    <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel = "icon" href =  "https://i.pinimg.com/originals/4a/a5/df/4aa5df83115df6c96732a2d76ccb4f1b.jpg" type = "image/x-icon"> 
    
<link rel="stylesheet" href="/css/styles.css">
 
<meta name="generator" content="Hexo 5.2.0"></head>

  <body>
    <div class="container">
      <!-- Header -->
      <link rel = "icon" href =  "https://i.pinimg.com/originals/4a/a5/df/4aa5df83115df6c96732a2d76ccb4f1b.jpg" type = "image/x-icon"> 
<nav id="nav">
  <header class="header">
    <a href="/" class="header-title">
      BLUR <i class="fa fa-fire" aria-hidden="true"></i>
    </a>
    
  </header>

  

  <div class="nav-wrapper">
    <div class="menu">
      <a href="/" class="nav-menu z-active">HOME</a>
      <a href="/about" class="nav-menu">ABOUT</a>
      <a href="/archives" class="nav-menu">ARCHIVE</a>
    </div>

    <div class="icons">
      <a target="_blank" rel="noopener" href="https://github.com/kiten46087" class="nav-icon" >
        <i class="fa fa-github-alt" aria-hidden="true"></i>
      </a>
      <a href="" class="nav-icon">
        <i class="fa fa-linkedin-square" aria-hidden="true"></i>
      </a>
      <a href="" class="nav-icon">
        <i class="fa fa-facebook-square" aria-hidden="true"></i>
      </a>
    </div>

    
  </div>
</nav>
    
<!-- <hr class="hr-divide-header" align="left"> -->
      <a name="top"></a>

<section class="article">  
  <h2 class="article-title">
    jcx blog 
  </h2>
  <p class="article-date">
    2020/10/6 
  </p>

  <hr class="hr-divide">

  <div class="article-content">
    <h1 id="HTTP学习"><a href="#HTTP学习" class="headerlink" title="HTTP学习"></a>HTTP学习</h1><hr>
<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>​    HTTP—Hyper Text Transfer Protocol，即超文本传输协议。</p>
<p>​    属于<strong>应用层</strong>的<strong>面向对象的协议</strong>，由请求和响应构成，是一个标准的<strong>C/S(客户端服务器)模型</strong>，适用于分布式超媒体信息系统。</p>
<p>　HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>
<p>　Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p>
<p>　Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>　HTTP默认端口号为80，也可以改为8080或者其他端口。</p>
<hr>
<h2 id="一、主要特点"><a href="#一、主要特点" class="headerlink" title="一、主要特点"></a>一、主要特点</h2><ol>
<li>支持客户 / 服务器模式</li>
</ol>
<ol start="2">
<li><p>客户向服务器请求服务时，只需传送请求方法和路径。</p>
<p><strong>请求类型</strong>：</p>
<ul>
<li><p><strong><em>GET</em></strong></p>
<p>  　　向特定的资源发出请求。</p>
<p>  　　请求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制，各个数据之间用”&amp;”符号隔开，传送的数据直接在浏览器的地址条里就能够看到。由于不同浏览器对地址的字符限制不同，GET方法也受此影响。</p>
</li>
<li><p><strong><em>POST</em></strong></p>
<p>​      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</p>
<p>​      将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</p>
</li>
<li><p>HEAD</p>
<p>​     与GET方法类似，主要请求获取响应消息报头，不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。主要用于测试当前的状态。</p>
</li>
<li><p>PUT</p>
<p>向指定资源位置上传其最新内容。</p>
<p>​     请求服务器存储一个资源，并用对应的URI作为其标识。</p>
</li>
<li><p>PATCH</p>
<p>是对 PUT 方法的补充，用来对已知资源进行局部更新 </p>
</li>
<li><p>DELETE</p>
<p>​     请求服务器删除URI所对应的资源。</p>
</li>
<li><p>TRACE</p>
<p>​     请求服务器会送收到的请求消息，主要用于测试或诊断。</p>
</li>
<li><p>OPTIONS</p>
<p>​     返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p>
</li>
<li><p>CONNECT</p>
<p>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。     </p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>灵活</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</p>
</li>
<li><p>无状态：</p>
<p>无状态是指协议对于事物处理没有记忆能力。这样在后续需要前面的信息时，它必须重传，可能导致每次连接传送的数据量增大。但是，在服务器不需要先前信息时，它的应答就较快。</p>
</li>
<li><p>媒体独立：</p>
<p>这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
</li>
<li><p>无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
</ol>
<hr>
<h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><p>　　HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。<strong>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<strong>服务器以一个状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h3 id="HTTP请求-相应步骤"><a href="#HTTP请求-相应步骤" class="headerlink" title="HTTP请求 / 相应步骤"></a>HTTP请求 / 相应步骤</h3><ol>
<li><p><strong>客户端连接到Web服务器</strong></p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，” <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> “</p>
</li>
<li><p><strong>发送Http请求</strong></p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成</p>
</li>
<li><p><strong>服务器接受请求并返回HTTP响应</strong></p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
</li>
<li><p><strong>释放连接TCP连接</strong></p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
</li>
<li><p><strong>客户端浏览器解析HTML内容</strong></p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
</li>
</ol>
<hr>
<p> 　　HTTP协议通常承载与TCP协议上（端口80）。另有HTTPS( Secure Hypertext Transfer Protocol )，即建立在SSL/TLS之上的http协议（端口443）。HTTP的信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议。</p>
<h3 id="有两种基本的加解密算法类型："><a href="#有两种基本的加解密算法类型：" class="headerlink" title="有两种基本的加解密算法类型："></a>有两种基本的加解密算法类型：</h3><ol>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ol>
<hr>
<h2 id="三、HTTP请求报文"><a href="#三、HTTP请求报文" class="headerlink" title="三、HTTP请求报文"></a>三、HTTP请求报文</h2><p>​         浏览器下按F12即可查看</p>
<p><img src="E:\Markdown\image\HTTP请求报文.png" alt="请求报文"></p>
<h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3><ol>
<li><p>请求行</p>
<p><strong>请求行以一个方法符号开头，以空格分开，后面跟着请求的uri和协议的版本</strong></p>
</li>
<li><p>请求头部</p>
</li>
<li><p>空行</p>
</li>
<li><p>请求数据</p>
</li>
</ol>
<p><strong>GET请求例子，使用Charles抓取的request：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;1b1b.jpg HTTP&#x2F;1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36</span><br><span class="line">Accept    image&#x2F;webp,image&#x2F;*,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Referer    http:&#x2F;&#x2F;www.imooc.com&#x2F;</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q&#x3D;0.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="　　第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a>　　第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</h5><p>GET说明请求类型为GET,[/1b1b.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="　　第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>　　第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>
<p>例：</p>
<p><img src="E:\Markdown\image\请求头部.png" alt="请求头部"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Host：请求的主机名</span><br><span class="line"></span><br><span class="line">User-Agent：浏览器的具体类型 </span><br><span class="line"></span><br><span class="line">Accept：浏览器支持哪些数据类型</span><br><span class="line"></span><br><span class="line">Accept-Language：浏览器的语言环境</span><br><span class="line"></span><br><span class="line">Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</span><br><span class="line"></span><br><span class="line">Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</span><br><span class="line"></span><br><span class="line">Connection：连接状态</span><br><span class="line"></span><br><span class="line">Upgrade-Insecure-Requests：是一个请求首部，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 upgrade-insecure-requests CSP 指令。</span><br></pre></td></tr></table></figure>

<h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="　　第三部分：空行，请求头部后面的空行是必须的"></a>　　第三部分：空行，请求头部后面的空行是必须的</h5><p>　　最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。即使第四部分的请求数据为空，也必须有空行。</p>
<h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="　　第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>　　第四部分：请求数据也叫主体，可以添加任意的其他数据。</h5><p>　　　　　　　这个例子的请求数据为空。</p>
<p>　 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<p> 　Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</p>
<p>​    Content-Length：表示请求消息正文的长度。</p>
<hr>
<h2 id="四、HTTP响应报文"><a href="#四、HTTP响应报文" class="headerlink" title="四、HTTP响应报文"></a>四、HTTP响应报文</h2><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个http的响应消息。</p>
<p> http响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p>
<p><img src="E:\Markdown\image\响应报文.png" alt="响应报文"></p>
<h5 id="第一部分：状态行"><a href="#第一部分：状态行" class="headerlink" title="第一部分：状态行"></a>第一部分：状态行</h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<h5 id="第二部分：消息报头-响应头部"><a href="#第二部分：消息报头-响应头部" class="headerlink" title="第二部分：消息报头 / 响应头部"></a>第二部分：消息报头 / 响应头部</h5><p>第二行和第三行为消息报头，用来说明客户端要使用的一些附加信息<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<h5 id="第三部分：空行，"><a href="#第三部分：空行，" class="headerlink" title="第三部分：空行，"></a>第三部分：空行，</h5><p>消息报头后面的空行是必须的</p>
<h5 id="第四部分：响应正文，"><a href="#第四部分：响应正文，" class="headerlink" title="第四部分：响应正文，"></a>第四部分：响应正文，</h5><p>服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</p>
<h3 id="请求返回状态码："><a href="#请求返回状态码：" class="headerlink" title="请求返回状态码："></a>请求返回状态码：</h3><p><strong>状态码分类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1**	   信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2**	   成功，操作被成功接收并处理</span><br><span class="line">3**	   重定向，需要进一步的操作以完成请求</span><br><span class="line">4**	   客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5**	   服务器错误，服务器在处理请求的过程中发生了错误</span><br></pre></td></tr></table></figure>

<p><strong>常用状态码：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">200 OK  请求成功。当您的操作将在响应正文中返回数据时，出现此结果。</span><br><span class="line"></span><br><span class="line">204 No Content 当您的操作成功，但不在响应正文中返回数据时，出现此结果。</span><br><span class="line"></span><br><span class="line">301 Moved Permanently 资源（网页等）被永久转移到其它URL。永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line"></span><br><span class="line">304 Not Modified（重定向）  当测试实体自上次检索以来是否被修改时，出现此结果。</span><br><span class="line"></span><br><span class="line">403 Forbidden   客户端错误</span><br><span class="line"></span><br><span class="line">401 Unauthorized 客户端错误</span><br><span class="line"></span><br><span class="line">413 Payload Too Large（客户端错误） 当请求长度过长时，出现此结果。</span><br><span class="line"></span><br><span class="line">400 BadRequest（客户端错误） 当参数无效时，出现此结果。</span><br><span class="line"></span><br><span class="line">404 Not Found（客户端错误） 请求的资源（网页等）不存在。 当资源不存在时，出现此结果。</span><br><span class="line"></span><br><span class="line">405 Method Not Allowed（客户端错误）由于方法和资源组合不正确而出现此错误。 例如，您不能对一个实体集合使用 DELETE 或 PATCH。</span><br><span class="line"></span><br><span class="line">412 Precondition Failed  客户端错误</span><br><span class="line"></span><br><span class="line">500 Internal Server Error 内部服务器错误</span><br><span class="line"></span><br><span class="line">501 Not Implemented（服务器错误） 当未实施某个请求的操作时，出现此结果。</span><br><span class="line"></span><br><span class="line">503 Service Unavailable（服务器错误） 当 Web API 服务不可用时，出现此结果。</span><br></pre></td></tr></table></figure>



<p>　　　<strong><em>更多状态码</em></strong>→<a href="e:/Markdown/链接用/状态码.md">状态码</a>            PS:右击链接打开</p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p><img src="E:\Markdown\image\响应头.png" alt="响应头"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    BDPAGETYPE</span><br><span class="line">    BDQID</span><br><span class="line">    BDUSERID</span><br><span class="line">    Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型</span><br><span class="line">    Connection：表示是否需要持续连接</span><br><span class="line">    Content-Encoding：web服务器支持的返回内容压缩编码</span><br><span class="line">    Content-Type：响应正文类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</span><br><span class="line">    Cxy_all</span><br><span class="line">    Date：请求发送的</span><br><span class="line">    Expires：响应过期的日期和时间</span><br><span class="line">    P3p</span><br><span class="line">    Server：web服务器软件名称</span><br><span class="line">    Set-Cookie：设置Http Cookie</span><br><span class="line">    Transfer-Encoding：文件传输编码</span><br><span class="line">    Vary：告诉下游代理是使用缓存响应还是从原始服务器请求</span><br><span class="line">    X-Powered-By</span><br><span class="line">    X-UA-Compatible</span><br><span class="line">    strict-transport-security</span><br><span class="line">   </span><br><span class="line">其他常见响应头：</span><br><span class="line">     Allow：服务器支持哪些请求方法(如GET、POST等)</span><br><span class="line">     </span><br><span class="line">     Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容</span><br><span class="line">     </span><br><span class="line">     Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置</span><br><span class="line">     </span><br><span class="line">     Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。</span><br><span class="line">              注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV&#x3D;&quot;Refresh&quot; ...＞。</span><br><span class="line">              </span><br><span class="line">     Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Allow	</span><br><span class="line">服务器支持哪些请求方法（如GET、POST等）。</span><br><span class="line"></span><br><span class="line">Content-Encoding	</span><br><span class="line">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压 缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的 Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</span><br><span class="line"></span><br><span class="line">Content-Length	</span><br><span class="line">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。</span><br><span class="line"></span><br><span class="line">Content-Type	</span><br><span class="line">表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</span><br><span class="line"></span><br><span class="line">Date	</span><br><span class="line">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</span><br><span class="line"></span><br><span class="line">Expires	</span><br><span class="line">应该在什么时候认为文档已经过期，从而不再缓存它？</span><br><span class="line"></span><br><span class="line">Last-Modified	</span><br><span class="line">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</span><br><span class="line"></span><br><span class="line">Location	</span><br><span class="line">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</span><br><span class="line"></span><br><span class="line">Server	</span><br><span class="line">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</span><br><span class="line"></span><br><span class="line">Set-Cookie	</span><br><span class="line">设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</span><br><span class="line"></span><br><span class="line">WWW-Authenticate	</span><br><span class="line">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的 应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;＼“executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="HTTP-无状态解决方法-——Cookie-Session简单了解"><a href="#HTTP-无状态解决方法-——Cookie-Session简单了解" class="headerlink" title="HTTP 无状态解决方法 ——Cookie / Session简单了解"></a>HTTP 无状态解决方法 ——Cookie / Session简单了解</h2><p>　　在程序中，会话跟踪是很重要的事情。 而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p>
<p> 　　Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
<p><strong>Cookie原理</strong></p>
<p>　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。于是给每个客户端颁发一个通行证，无论谁访问都必须携带自己通行证，这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p><strong>查看某个网站颁发的Cookie</strong></p>
<p>​                       在浏览器地址栏输入<strong>JavaScript:alert (document. cookie)</strong><img src="E:\Markdown\image\网站Cookie1.jpg" alt="网站Cookie1" style="zoom:50%;" /><img src="E:\Markdown\image\网站Cookie2.jpg" alt="网站Cookie2" style="zoom:50%;" /></p>
<hr>
<p>​       除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。  </p>
<p><strong>Session原理</strong></p>
<p>​      Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。如同服务器端的档案。</p>
<hr>
<h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><p>　　WEB缓存(cache)位于Web服务器和客户端之间。</p>
<p>　　缓存会根据请求保存输出内容的副本，例如html页面，图片，文件。当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。一方面减少了延迟，另一方面也减少了带宽的消耗。</p>
<p>　　HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p>
<p>　　HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。减少发送请求就减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来达到此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来达到此目的。</p>
<p>​    <strong>HTTP定义了3种缓存机制</strong></p>
<p>​     1. Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。</p>
<p>​     2. Validation：用来检查以一个缓存的回应是否仍然可用。</p>
<p>​     3. Invalidation： 在另一个请求通过缓存的时候，常常有一个副作用。</p>
<hr>
<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>　　代理服务器Proxy Server，类似网络信息中转站，是介于浏览器和Web服务器i之间的一台服务器。浏览器向代理服务器发送请求，代理服务器接收请求，再按要求获取信息，然后再将取得的信息传送给浏览器。</p>
<p>　　代理服务器一般都具有缓冲功能，可以不断的将心取得的数据存储在本机上，如果浏览器所请求的数据在代理服务器上已经存在，就不用从web服务器取取数据，直接将存储器上的数据传送给用户的浏览器。</p>
<p><img src="E:\Markdown\image\HTTP代理.jpg" alt="HTTP代理"></p>
<hr>
<h3 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h3><p>　　content-type（内容类型），一般是指网页中存在的 content-type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 php 网页点击的结果却是下载一个文件或一张图片的原因。 </p>
<p>　　content-type 标头告诉客户端实际返回的内容的内容类型。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;something</span><br></pre></td></tr></table></figure>

<p><strong>常见的媒体格式类型如下：</strong></p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p><strong>以application开头的媒体格式类型：</strong></p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml： XML数据格式</li>
<li>application/atom+xml ：Atom XML聚合格式</li>
<li>application/json： JSON数据格式</li>
<li>application/pdf：pdf格式</li>
<li>application/msword ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p><strong>另外一种常见的媒体格式是上传文件之时使用的：</strong></p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<p>​      </p>
<p><strong>content-type 对照表</strong>   →   [link](e:/Markdown/链接用/content-type 对照表.md)        PS:右击打开链接</p>
 
    <hr class="hr-divide">
    <div class="article-footer">
      <a href="#top">back to top</a>
    </div>
  </div>

  
</section>  
      <!-- Footer -->
      <!-- <h1>This is the footer.ejs file</h1> -->

<footer class="footer">
  <p style="margin-top: 0px;">
    Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
    Created by <a href="">@Qitian Lin</a>
  </p>
</footer>  
    </div>

    <!-- After footer file to store js of Bootstrap -->
    <!-- <h1>This is the after-footer ejs file</h1> -->
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
 
  </body>

</html>