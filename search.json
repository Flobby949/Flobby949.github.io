[{"title":"http study","url":"http://example.com/2020/10/06/article-title/","content":"HTTP学习\n概述：​    HTTP—Hyper Text Transfer Protocol，即超文本传输协议。\n​    属于应用层的面向对象的协议，由请求和响应构成，是一个标准的C/S(客户端服务器)模型，适用于分布式超媒体信息系统。\n　HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\n　Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\n　Web服务器根据接收到的请求后，向客户端发送响应信息。\n　HTTP默认端口号为80，也可以改为8080或者其他端口。\n\n一、主要特点\n支持客户 / 服务器模式\n\n\n客户向服务器请求服务时，只需传送请求方法和路径。\n请求类型：\n\nGET\n  　　向特定的资源发出请求。\n  　　请求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制，各个数据之间用”&amp;”符号隔开，传送的数据直接在浏览器的地址条里就能够看到。由于不同浏览器对地址的字符限制不同，GET方法也受此影响。\n\nPOST\n​      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。\n​      将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，POST方式对传送的数据大小没有限制，而且也不会显示在URL中。\n\nHEAD\n​     与GET方法类似，主要请求获取响应消息报头，不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。主要用于测试当前的状态。\n\nPUT\n向指定资源位置上传其最新内容。\n​     请求服务器存储一个资源，并用对应的URI作为其标识。\n\nPATCH\n是对 PUT 方法的补充，用来对已知资源进行局部更新 \n\nDELETE\n​     请求服务器删除URI所对应的资源。\n\nTRACE\n​     请求服务器会送收到的请求消息，主要用于测试或诊断。\n\nOPTIONS\n​     返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。\n\nCONNECT\nHTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。     \n\n\n\n\n\n灵活\nHTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记\n\n无状态：\n无状态是指协议对于事物处理没有记忆能力。这样在后续需要前面的信息时，它必须重传，可能导致每次连接传送的数据量增大。但是，在服务器不需要先前信息时，它的应答就较快。\n\n媒体独立：\n这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。\n\n无连接：\n无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n\n\n二、工作原理　　HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\nHTTP请求 / 相应步骤\n客户端连接到Web服务器\n一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，” http://www.baidu.com “\n\n发送Http请求\n通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成\n\n服务器接受请求并返回HTTP响应\nWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n\n释放连接TCP连接\n若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n\n客户端浏览器解析HTML内容\n客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n\n\n 　　HTTP协议通常承载与TCP协议上（端口80）。另有HTTPS( Secure Hypertext Transfer Protocol )，即建立在SSL/TLS之上的http协议（端口443）。HTTP的信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议。\n有两种基本的加解密算法类型：\n对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；\n非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。\n\n\n三、HTTP请求报文​         浏览器下按F12即可查看\n\n组成：\n请求行\n请求行以一个方法符号开头，以空格分开，后面跟着请求的uri和协议的版本\n\n请求头部\n\n空行\n\n请求数据\n\n\nGET请求例子，使用Charles抓取的request：\nGET &#x2F;1b1b.jpg HTTP&#x2F;1.1Host    img.mukewang.comUser-Agent    Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36Accept    image&#x2F;webp,image&#x2F;*,*&#x2F;*;q&#x3D;0.8Referer    http:&#x2F;&#x2F;www.imooc.com&#x2F;Accept-Encoding    gzip, deflate, sdchAccept-Language    zh-CN,zh;q&#x3D;0.8\n\n\n\n　　第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/1b1b.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。\n　　第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等\n例：\n\nHost：请求的主机名User-Agent：浏览器的具体类型 Accept：浏览器支持哪些数据类型Accept-Language：浏览器的语言环境Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。Connection：连接状态Upgrade-Insecure-Requests：是一个请求首部，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 upgrade-insecure-requests CSP 指令。\n\n　　第三部分：空行，请求头部后面的空行是必须的　　最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。即使第四部分的请求数据为空，也必须有空行。\n　　第四部分：请求数据也叫主体，可以添加任意的其他数据。　　　　　　　这个例子的请求数据为空。\n　 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n 　Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’\n​    Content-Length：表示请求消息正文的长度。\n\n四、HTTP响应报文一般情况下，服务器接收并处理客户端发过来的请求后会返回一个http的响应消息。\n http响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文\n\n第一部分：状态行第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）\n由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n第二部分：消息报头 / 响应头部第二行和第三行为消息报头，用来说明客户端要使用的一些附加信息Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8\n第三部分：空行，消息报头后面的空行是必须的\n第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。\n请求返回状态码：状态码分类\n1**\t   信息，服务器收到请求，需要请求者继续执行操作2**\t   成功，操作被成功接收并处理3**\t   重定向，需要进一步的操作以完成请求4**\t   客户端错误，请求包含语法错误或无法完成请求5**\t   服务器错误，服务器在处理请求的过程中发生了错误\n\n常用状态码：\n200 OK  请求成功。当您的操作将在响应正文中返回数据时，出现此结果。204 No Content 当您的操作成功，但不在响应正文中返回数据时，出现此结果。301 Moved Permanently 资源（网页等）被永久转移到其它URL。永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替304 Not Modified（重定向）  当测试实体自上次检索以来是否被修改时，出现此结果。403 Forbidden   客户端错误401 Unauthorized 客户端错误413 Payload Too Large（客户端错误） 当请求长度过长时，出现此结果。400 BadRequest（客户端错误） 当参数无效时，出现此结果。404 Not Found（客户端错误） 请求的资源（网页等）不存在。 当资源不存在时，出现此结果。405 Method Not Allowed（客户端错误）由于方法和资源组合不正确而出现此错误。 例如，您不能对一个实体集合使用 DELETE 或 PATCH。412 Precondition Failed  客户端错误500 Internal Server Error 内部服务器错误501 Not Implemented（服务器错误） 当未实施某个请求的操作时，出现此结果。503 Service Unavailable（服务器错误） 当 Web API 服务不可用时，出现此结果。\n\n\n\n　　　更多状态码→状态码            PS:右击链接打开\n响应头\n    BDPAGETYPE    BDQID    BDUSERID    Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型    Connection：表示是否需要持续连接    Content-Encoding：web服务器支持的返回内容压缩编码    Content-Type：响应正文类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。    Cxy_all    Date：请求发送的    Expires：响应过期的日期和时间    P3p    Server：web服务器软件名称    Set-Cookie：设置Http Cookie    Transfer-Encoding：文件传输编码    Vary：告诉下游代理是使用缓存响应还是从原始服务器请求    X-Powered-By    X-UA-Compatible    strict-transport-security   其他常见响应头：     Allow：服务器支持哪些请求方法(如GET、POST等)          Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容          Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置          Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。              注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV&#x3D;&quot;Refresh&quot; ...＞。                   Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；\n\n\n\nAllow\t服务器支持哪些请求方法（如GET、POST等）。Content-Encoding\t文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压 缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的 Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。Content-Length\t表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。Content-Type\t表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。Date\t当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。Expires\t应该在什么时候认为文档已经过期，从而不再缓存它？Last-Modified\t文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。Location\t表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。Server\t服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。Set-Cookie\t设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。WWW-Authenticate\t客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的 应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;＼“executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n\n\n\nHTTP 无状态解决方法 ——Cookie / Session简单了解　　在程序中，会话跟踪是很重要的事情。 而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。\n 　　Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。\nCookie原理\n　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。于是给每个客户端颁发一个通行证，无论谁访问都必须携带自己通行证，这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。\n查看某个网站颁发的Cookie\n​                       在浏览器地址栏输入JavaScript:alert (document. cookie)\n\n​       除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。  \nSession原理\n​      Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。如同服务器端的档案。\n\nHTTP缓存机制　　WEB缓存(cache)位于Web服务器和客户端之间。\n　　缓存会根据请求保存输出内容的副本，例如html页面，图片，文件。当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。一方面减少了延迟，另一方面也减少了带宽的消耗。\n　　HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。\n　　HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。减少发送请求就减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来达到此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来达到此目的。\n​    HTTP定义了3种缓存机制\n​     1. Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。\n​     2. Validation：用来检查以一个缓存的回应是否仍然可用。\n​     3. Invalidation： 在另一个请求通过缓存的时候，常常有一个副作用。\n\nHTTP代理　　代理服务器Proxy Server，类似网络信息中转站，是介于浏览器和Web服务器i之间的一台服务器。浏览器向代理服务器发送请求，代理服务器接收请求，再按要求获取信息，然后再将取得的信息传送给浏览器。\n　　代理服务器一般都具有缓冲功能，可以不断的将心取得的数据存储在本机上，如果浏览器所请求的数据在代理服务器上已经存在，就不用从web服务器取取数据，直接将存储器上的数据传送给用户的浏览器。\n\n\nHTTP content-type　　content-type（内容类型），一般是指网页中存在的 content-type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 php 网页点击的结果却是下载一个文件或一张图片的原因。 \n　　content-type 标头告诉客户端实际返回的内容的内容类型。\n语法格式\nContent-Type: text&#x2F;html; charset&#x3D;utf-8Content-Type: multipart&#x2F;form-data; boundary&#x3D;something\n\n常见的媒体格式类型如下：\n\ntext/html ： HTML格式\ntext/plain ：纯文本格式\ntext/xml ： XML格式\nimage/gif ：gif图片格式\nimage/jpeg ：jpg图片格式\nimage/png：png图片格式\n\n以application开头的媒体格式类型：\n\napplication/xhtml+xml ：XHTML格式\napplication/xml： XML数据格式\napplication/atom+xml ：Atom XML聚合格式\napplication/json： JSON数据格式\napplication/pdf：pdf格式\napplication/msword ： Word文档格式\napplication/octet-stream ： 二进制流数据（如常见的文件下载）\napplication/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）\n\n另外一种常见的媒体格式是上传文件之时使用的：\n\nmultipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n​      \ncontent-type 对照表   →   [link](e:/Markdown/链接用/content-type 对照表.md)        PS:右击打开链接\n","categories":[],"tags":[]}]